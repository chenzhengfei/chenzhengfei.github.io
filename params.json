{
  "name": "使用 lombok 简化 Java 代码",
  "tagline": "",
  "body": "## 本文简单介绍 lombok 这种可以简化 Java 代码的工具。\r\n\r\n## 一个典型的 Java 类\r\n\r\n```java\r\npublic class A {\r\n\r\n  private int a;\r\n\r\n  private String b;\r\n\r\n  public int getA() {\r\n    return a;\r\n  }\r\n\r\n  public String getB() {\r\n    return b;\r\n  }\r\n\r\n  public void setA(int a) {\r\n    this.a = a;\r\n  }\r\n\r\n  public void setB(String b) {\r\n    this.b = b;\r\n  }\r\n\r\n}\r\n```\r\n\r\n对于这样一个简单的 Java 类，我们通常需要给每个属性写`getter`和`setter`，而这种实际上没有什么太大的意义。当然，如果有的公司或团队使用代码行数评估工作量，还是多写几行吧；同时，可以考虑一下我们团队。\r\n\r\n## 使用 lombok，简化代码\r\n\r\n为了简化`getter`与`setter`，lombok 提供了一种机制，帮助我们自动生成这些样板代码。以上的代码，如果使用`lombok`的话，将变得很简单：\r\n\r\n```java\r\n@lombok.Getter\r\n@lombok.Setter\r\npublic class A {\r\n\r\n    private int a;\r\n\r\n    private String b;\r\n\r\n}\r\n```\r\n\r\n顾名思义，`lombok.Getter`就是生成`getter`，`lombok.Setter`就是生成`setter`。但是，这样真的就可以了么？编译下，让我们看看生成的二进制代码。(请自行下载`lombok.jar`)\r\n\r\n```\r\n命令行> javac -cp lombok.jar A.java\r\n命令行> javap -c A.class\r\n```\r\n\r\n输出结果略。可以看到完全一样。\r\n\r\n更进一步，如果在编译的时候，加入`-g:none`选项，甚至可以看到生成的文件**完全**一样。\r\n\r\n## 简单使用\r\n\r\n虽然我们可以在编译的时候，加入`classpath`，但是，一般来说，在各类`IDE`中使用，还是需要特殊处理一下。\r\n\r\n### Maven\r\n\r\n加上依赖就好。同时，由于`lombok`只在编译期才处理，所以并不需要在运行时有这个依赖，可以把`scope`定义为`provided`。\r\n\r\n```xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>org.projectlombok</groupId>\r\n        <artifactId>lombok</artifactId>\r\n        <version>1.16.8</version>\r\n        <scope>provided</scope>\r\n    </dependency>\r\n</dependencies>\r\n```\r\n\r\n值得注意的是，`maven`的`maven-compiler-plugin`低版本和`lombok`高版本不兼容，目前已知`maven-compiler-plugin`的`2.3.X`与`lombok`的`1.6.X`不兼容。这个需要了解`lombok`的原理才能进一步说明。\r\n\r\n### Eclipse\r\n\r\n由于`eclipse`的默认编译器并不是`javac`，所以，需要额外安装，基本就是改下引导参数，可以直接运行`jar`包，或者手动在`eclipse.ini`里加上参数`-Xbootclasspath/a:lombok.jar -javaagent:lombok.jar`。\r\n\r\n### IDEA IntelliJ\r\n\r\n虽然`IDEA IntelliJ`默认使用`javac`作为编译器，理论上可以不装插件。可是，跳转等特性也随之没了。所以，还是安装个插件吧，直接去仓库里搜索`lombok`就成。\r\n\r\n如果项目中使用高级配置，需要额外注意一下。虽然在编译的时候，`lombok`配置文件可以在任何能找到的目录，但是，`lombok-intellij`插件默认并不支持在任何目录，如果有配置文件，建议放在`java`的源代码根目录中。\r\n\r\n## 更多 lombok 注解\r\n\r\nlombok 目前最新版本为 1.16.8，个人觉得比较常用的有以下几种，更多请查看官网。\r\n\r\n* `@val`\r\n\r\n  如果你要定义一个`final`的变量，并且不想写类型，这个可以帮到你。但是，在实际项目中，完全没有使用到。\r\n\r\n* `@NonNull`\r\n\r\n  这个在参数中使用，如果调用时传了`null`，就直接抛空指针。\r\n\r\n* `@Data`\r\n\r\n  `@ToString`、`@EqualsAndHashCode`、`@Getter`、`@Setter`和`@RequiredArgsConstructor`注解的集合。\r\n\r\n* `@Getter`与`@Setter`\r\n\r\n  作用于属性和类上，自动生成属性的`getXXX()`和`setXXX()`方法。若在类上，则对所有属性有效。并可通过`AccessLevel`参数控制方法的访问级别。\r\n\r\n* `@ToString`\r\n\r\n  作用于类，自动重写类的`ToString()`方法。常用的参数有`exclude`（指定方法中不包含的属性）、`callSuper`（方法中是否包含父类`ToString()`方法返回的值）\r\n\r\n* `@EqualsAndHashCode`\r\n\r\n  作用于类，自动重写类的`equals()`、`hashCode()`方法。常用的参数有`exclude`（指定方法中不包含的属性）、`callSuper`（方法中是否包含父类`ToString()`方法返回的值）\r\n\r\n* `@NoArgsConstructor`, `@RequiredArgsConstructor`和`@AllArgsConstructor`\r\n\r\n  作用于类，`@NoArgsConstructor`自动生成不带参数的构造方法；`@RequiredArgsConstructor`自动生成带参数的构造方法，主要针对一些需要特殊处理的属性，比如未初始化的`final`属性；`@AllArgsConstructor`自动生成包含所有属性的构造方法。\r\n\r\n* `@Synchronized`\r\n\r\n  作用于方法，可锁定指定的对象，如果不指定，则默认创建创建一个对象锁定。\r\n\r\n* `@Log`，或者直接`@Slf4j`\r\n\r\n  作用于类，具体包含`@CommonsLog`、`@Log`、`@Log4j`、`@Log4j2`、`@Slf4j`和``@XSlf4j`，分别对用不同的日志系统。利用此类注解，可为类创建一个`log`属性。\r\n\r\n## sonar 源码审查\r\n\r\n`sonar`是一个源码审查工具。最新版`5.X`已经支持`lombok`的全部注解，不再认为是没有使用的变量。但是，旧的`4.X`还是认为没有使用这些变量。可以后向移植这些包，或者应用单独的补丁。\r\n\r\n## 原理\r\n\r\n呃，真的有人想看原理么？如果想，请留言，以后再发。\r\n\r\n## 参考文献\r\n\r\n1. [lombok](https://projectlombok.org/), lombok 官网，但是，目前没有发现哪里可以捐赠\r\n2. [sonar](http://www.sonarqube.org/), sonar 官网，对代码规范有一些建议\r\n3. [sonar-java](https://github.com/liudongmiao/sonar-java/releases), sonar-java 低版本插件，支持`lombok`",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}